const cds = require('@sap/cds')
const { fs, path } = cds.utils
const util = require('util')
const exec = util.promisify(require('child_process').exec)
const { readdir, stat } = require('fs/promises')
const DEBUG = cds.debug('cli|build')

const BUILD_CONFIG = 'tsconfig.build.json'
const tsConfigExists = () => fs.existsSync('tsconfig.json')
const buildConfigExists = () => fs.existsSync(BUILD_CONFIG)
const rmDirIfExists = dir => {
  try { fs.rmSync(dir, { recursive: true }) } catch { /* ignore */ }
}
const rmFiles = async (dir, exts) => Promise.all(
  (await readdir(dir))
    .map(async file => {
      const filePath = path.join(dir, file)
      if ((await stat(filePath)).isDirectory()) {
        return rmFiles(filePath, exts)
      } else if (exts.some(ext => file.endsWith(ext))) {
        fs.unlinkSync(filePath)
      }
    })
)

// requires @sap/cds-dk version >= 7.5.0
cds.build?.register?.('typescript', class extends cds.build.Plugin {
  static taskDefaults = { src: '.' }
  static hasTask() { return tsConfigExists() }

  get priority() { return 1 } // should run after the node build task FIXME: set to 0 once that is allowed

  init() {
    // different from the default build output structure
    this.task.dest = path.join(cds.root, 'gen', 'srv')
    //this.task.dest = path.join(cds.root, cds.env.build.target !== '.' ? cds.env.build.target : 'gen')
  }

  get #modelDirectoryName () {
    // FIXME: dynamically retrieve the model directory name from tsconfig.
    // This would require us to be able to consume jsonc, as tsconfigs can contain comments.
    return '@cds-models'
  }

  createBuildTSConfig () {
    if (fs.existsSync(BUILD_CONFIG)) return
    const tsConfig = {
      'extends': './tsconfig.json',
      'compilerOptions': {
        'outDir': 'gen'
      },
      'exclude': ['gen', 'app']
    }
    fs.writeFileSync(BUILD_CONFIG, JSON.stringify(tsConfig, null, 2))
  }

  async #runCdsTyper () {
    DEBUG?.('running cds-typer')
    await exec('npx @cap-js/cds-typer "*" --outputDirectory @cds-models')
  }

  async #buildWithConfig () {
    DEBUG?.(`building with config ${BUILD_CONFIG}`)
    return exec(`npx tsc --project ${BUILD_CONFIG}`)
  }

  async #buildWithoutConfig () {
    DEBUG?.('building without config')
    // this will include gen/ that was created by the nodejs task
    // _within_ the project directory. So we need to remove it afterwards.
    await exec(`npx tsc --outDir ${this.task.dest}`)
    rmDirIfExists(path.join(this.task.dest, 'gen'))
    rmDirIfExists(path.join(this.task.dest, 'app'))
  }

  async #copyCleanModel (buildDirCdsModels) {
    // copy models again, to revert transpilation thereof.
    // We only need the index.js files in un-transpiled form.
    await this.copy('@cds-models').to(buildDirCdsModels)
    await rmFiles(buildDirCdsModels, ['.ts'])
  }

  async build() {
    //this.createBuildTSConfig()
    await this.#runCdsTyper()
    const buildDirCdsModels = path.join(this.task.dest, this.#modelDirectoryName)
    // remove the js files generated by the nodejs buildtask,
    // leaving only json, cds, and other static files
    await rmFiles(this.task.dest, ['.js', '.ts'])

    try {
      if (buildConfigExists()) {
        await this.#buildWithConfig()
      }
      else {
        await this.#buildWithoutConfig()
      }
    } catch (error) {
      throw error.stdout
        ? new Error(error.stdout)
        : error
    }

    this.#copyCleanModel(buildDirCdsModels)
  }
})